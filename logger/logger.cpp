/**
 * @file logger.cpp
 *
 * @brief This file contains the source code defining the classes for message reception and storage.
 *
 * @details It implements functionalities related to the reception of logs generated by the Raspberry Pi Pico,
 * as well as the storage of these logs.
 *
 * @author João Cláudio Elsen Barcellos <joao.barcellos@posgrad.ufsc.br>
 * @version 0.0.0
 *
 * @date 12/11/2023
 */

#include "logger.h"

Logger::Logger(){}
Logger::~Logger(){
    close(tty);
    close(log);
}

int Logger::serialPortConfig(const char* tty_channel, const char* log_file_name){
    int err = 0;

    tty = open(tty_channel, O_RDWR | O_NDELAY | O_NOCTTY);
    if (tty < 0)
        err = -1;
    else {
        // Configure baud rate to 115200 bps
        cfsetispeed(&options, B115200); // Input speed set to 115200 bps
        cfsetospeed(&options, B115200); // Output speed set to 115200 bps
        
        // Enable the receiver and set local mode
        options.c_cflag |= (CLOCAL | CREAD);
        
        options.c_cflag &= ~PARENB; // Disable parity
        options.c_cflag &= ~CSTOPB; // Set for 1 stop bit 
        options.c_cflag &= ~CSIZE;  // Clear character size bits 
        options.c_cflag |= CS8;     // Set data bits to 8 
        
        // Set for raw input mode
        options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
        
        // Set for raw output mode
        options.c_oflag &= ~OPOST;
        
        // Apply the modified options to the port immediately
        tcsetattr(tty, TCSANOW, &options);
    }

    return err;
}

void Logger::serialPortRead(){
    int count = 0;
    while(1){
        len = read(tty, &newChar, 1);

        if(len > 0){
            if (newChar == '\n') {
                buffer[index++] = '\n';
                buffer[index++] = '\0'; // Adiciona terminador nulo para formar uma string
                if(strncmp(buffer, "ID69", 4) == 0){
                    updateLogFile(&count);
                    logQueue.insertLog(std::string(buffer));
                }
                else if(strncmp(buffer, "echo", 4) == 0)
                    write(tty, buffer, strlen(buffer));
                memset(buffer, 0, sizeof(buffer)); // Limpa o array message
                index = 0; // Reseta a posição do buffer   
            }
            else{
                buffer[index++] = newChar; // Adiciona o caractere lido ao buffer
                if (index >= sizeof(buffer) - 1) {
                    buffer[sizeof(buffer) - 1] = '\0';
                    index = 0; // Reseta a posição do buffer
                }
            }
        }
        usleep(1000); // Pequena pausa para não consumir muita CPU
    }
}

void Logger::updateLogFile(int* count){
    log = open("serial_log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if(log < 0)
        cout << "Something wrong happened" << "\n";
    
    if((*count) > 10){
        (*count) = 0;
        while (!logQueue.isEmpty()){
            string data = logQueue.readFirstLog();
            write(log, data.c_str(), strlen(data.c_str()));
            logQueue.removeFirstLog();
        }           
    }
    else{
        (*count)++;   
    }
    fsync(log); // Ensure data is written to disk
    close(log); // Close the file after writing
}
