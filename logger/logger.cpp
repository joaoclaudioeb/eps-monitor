/**
 * @file logger.cpp
 *
 * @brief This file contains the source code defining the classes for message reception and storage.
 *
 * @details It implements functionalities related to the reception of logs generated by the Raspberry Pi Pico,
 * as well as the storage of these logs.
 *
 * @author João Cláudio Elsen Barcellos <joao.barcellos@posgrad.ufsc.br>
 * @version 0.0.0
 *
 * @date 12/11/2023
 */

#include "logger.h"

Logger::Logger(){}
Logger::~Logger(){
    close(tty);
    close(log);
}

int Logger::serialPortConfig(const char* tty_channel, const char* log_file_name){
    int err = 0;

    tty = open(tty_channel, O_RDWR | O_NDELAY | O_NOCTTY);
    if (tty < 0)
        err = -1;
    else {
        /**
         * Configuring the input and output baudrate to 115200 bps
         */ 
        cfsetispeed(&options, B115200); 
        cfsetospeed(&options, B115200); 
        /**
         * Enables the receiver and disables the interpretation of modem control lines
         */
        options.c_cflag |= (CLOCAL | CREAD);
        /**
         * Disables the parity bit
         * Sets the stop bit to '1'
         * Ensuring that existing settings related to character size are cleared
         * before applying new settings
         * Set the size of data to '8 bits'
         */
        options.c_cflag &= ~PARENB; 
        options.c_cflag &= ~CSTOPB;  
        options.c_cflag &= ~CSIZE;   
        options.c_cflag |= CS8;      
        /**
         * Configuring as non-canonical input
         */
        options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
        /**
         * Configuring as non-canonical output
         */
        options.c_oflag &= ~OPOST;
        /**
         * Apply the modified options to the port immediately
         */
        tcsetattr(tty, TCSANOW, &options);
    }

    return err;
}

void Logger::serialPortRead(){
    int count = 0;
    while(1){
        len = read(tty, &newChar, 1);

        if(len > 0){
            if (newChar == '\n') {
                buffer[index++] = '\n';
                buffer[index++] = '\0'; // Adds an '\0' to create a string
                if(strncmp(buffer, "ID69", 4) == 0){
                    updateLogFile(&count);
                    logQueue.insertLog(string(buffer));
                }
                else if(strncmp(buffer, "echo", 4) == 0){
                    write(tty, buffer, strlen(buffer));
                }
                memset(buffer, 0, sizeof(buffer)); // Clear 'message' 
                index = 0; // Resets the index   
            }
            else{
                buffer[index++] = newChar; // Adds the read character to the buffer
                if (index >= sizeof(buffer) - 1) {
                    buffer[sizeof(buffer) - 1] = '\0';
                    index = 0; // Resets the index
                }
            }
        }
        usleep(1000); // A short-break
    }
}

void Logger::updateLogFile(int* count){
    log = open("serial_log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if(log < 0)
        cout << "Something wrong happened" << "\n";
    
    if((*count) > 10){
        (*count) = 0;
        while (!logQueue.isEmpty()){
            string data = logQueue.readFirstLog();
            write(log, data.c_str(), strlen(data.c_str()));
            logQueue.removeFirstLog();
        }           
    }
    else{
        (*count)++;   
    }
    fsync(log); // Ensure data is written to disk
    close(log); // Close the file after writing
}
